---
layout: post
title:  "生成元(Digit Generator UVA1583)"
date:   2018-07-29 11:23:49 +0800
categories: C-program-language
tags: C-program-language
img: http://or4d8nhvk.bkt.clouddn.com/18-7-28/46642653.jpg
author: DND
---

这个世界本来就是相互矛盾的，也是很公平的，不是么？

* 
{:toc}

## 算法

### 题目描述
```
如果x加上x的各位数之和等于y，就说x是y的生成元.
给出n(1<=n<=100000),求n的最小生成元,  无解输出0.
例如 n=216,121,2005 应输出 198 0 1979
输入的第一行是几个样例，剩下的是输入的样例
样例输入：
3 
216 
121 
2005

样例输出：
198 
0 
1979

```

### 代码部分

```
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100010
int arr[MAX_SIZE];
int main()
{
    memset(arr,0,sizeof(arr));
    int T,n,i;
    for(i=1; i<MAX_SIZE; i++)
    {
        int x=i,y=i;
        while(x>0)
        {
            y=y+x%10;
            x=x/10;
        }
        if(arr[y]==0||i<arr[y])arr[y]=i;

    }
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        printf("%d\n",arr[n]);
    }

    return 0;
}



```
### 代码感悟
此题各种变量很多，容易记混( Ĭ ^ Ĭ )，要用到一个变量写一个变量，不然容易混。
吃了个饭，回来继续写，难点在于第二点：有多少数字在两个序列都出现过但位置不对。
求这个的思路是：对于1~9的每个数，统计正确答案中各个数字所出现的次数，用数组保存，
再统计猜的答案中所出现的次数，用另一个数组保存，将统计的结果再放到第三个新开辟的数组中，
将第三个数组中所有的数据进行相加，再减去统计有多少数字位置正确的个数，即是要求的结果。
感觉我说的有点绕φ(．．｡)，语言表达力欠缺，也就是这个意思✺◟(∗❛ัᴗ❛ั∗)◞✺，

接下来就是放松的时候了ヾ(･ω･*)ﾉ，分享三张2K~4K画质的海贼王桌面o(￣▽￣)ｄ 

![](http://or4d8nhvk.bkt.clouddn.com/18-7-28/55225892.jpg)
![](http://or4d8nhvk.bkt.clouddn.com/18-7-28/37857382.jpg)
![](http://or4d8nhvk.bkt.clouddn.com/18-7-28/16820818.jpg)

最后的最后再来一段《道德经》，争取假期的博客将《道德经》写一遍╮(￣▽￣)╭，
好好再体会一遍这本书的魅力(*/ω＼*)
话说那个“歙（xi）”字好难打啊(｀・ω・´)

> 将欲歙之，必固张之；  
将欲弱之，必固强之；   
将欲废之，必固兴之；    
将欲夺之，必固与之；  
是谓微明。  
柔弱胜刚强。  
鱼不可脱于渊，  
国之利器不可以示人。  
