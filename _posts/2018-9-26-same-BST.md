---
layout: post
title:  "是否是同一棵BST树"
date:   2018-09-26 12:59:49 +0800
categories: Datastructure
tags: Datastructure
img: http://or4d8nhvk.bkt.clouddn.com/18-9-26/66946335.jpg
author: DND
---

依旧是关于树的一道数据结构基础题，题目是：是否是同一棵BST树。

* 
{:toc}

## 算法

### 题目描述
```
给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。

输入格式:
输入包含若干组测试数据。每组数据的第1行给出两个正整数N (≤10)和L，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出N个以空格分隔的正整数，作为初始插入序列。最后L行，每行给出N个插入的元素，属于L个需要检查的序列。

简单起见，我们保证每个插入序列都是1到N的一个排列。当读到N为0时，标志输入结束，这组数据不要处理。

输出格式:
对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。

输入样例:
4 2
3 1 4 2
3 4 1 2
3 2 4 1
2 1
2 1
1 2
0
输出样例:
Yes
No
No
```
### 代码部分

```c++
#include <stdio.h>
#include <stdlib.h>
typedef struct TreeNode* Tree;
struct TreeNode{
    int v;
    Tree Left,Right;
    int flag;//作为树是否被访问的标志
};

Tree NewNode(int V){
    Tree T = new TreeNode;
    T->v=V;
    T->Left=T->Right=NULL;
    T->flag=0;
    return T;
}

int check(Tree T,int Value){
    if (T->flag) {
        if (Value<T->v)
            return check(T->Left,Value);
        else if (Value>T->v)
            return check(T->Right, Value);
        else
            return 0;
    }else {
        if (Value==T->v) {
            T->flag=1;
            return 1;
        }
        else {
            return 0;
        }
    }
}

int Judge(Tree T,int N){
    int i,V,tag=0;/*tag为0代表目前还不一致，1代表已经不一致*/

    scanf("%d",&V);
    if (V!=T->v) {
        tag=1;
    }else {
        T->flag=1;
    }
    for (i=1;i<N;i++) {
        scanf("%d",&V);
        if ((!tag)&&(!check(T, V))) {
            tag=1;
        }
    }
    if (tag) {
        return 0;
    }else {
        return 1;
    }
}

void ResetT(Tree T){
    if (T->Left) {
        ResetT(T->Left);
    }
    if (T->Right) {
        ResetT(T->Right);
    }
    T->flag=0;
}

void FreeTree(Tree T){
    if (T->Left) {
        FreeTree(T->Left);
    }
    if (T->Right) {
        FreeTree(T->Right);
    }
    free(T);
}

Tree Insert(Tree T,int V){
    if (!T) {
        T = NewNode(V);
    }else {
        if (V>T->v) {
            T->Right=Insert(T->Right, V);

        }else {
            T->Left=Insert(T->Left, V);
        }
    }
    return T;
}

Tree MakeTree(int N){
    Tree T;
    int i,V;

    scanf("%d",&V);

    T=NewNode(V);
    for (i = 1;i < N;i++) {
        scanf("%d",&V);
        T=Insert(T,V);
    }
    return T;
}


int main(int argc, char *argv[]) {
    int N,L,i;

    Tree T;
    scanf("%d",&N);
    while(N){
        scanf("%d",&L);
        T=MakeTree(N);
        for(i = 0; i < L; i++){
            if (Judge(T,N)) {
                printf("Yes\n");
            }else{
                printf("No\n");
            }
            ResetT(T);//清除T中的标记flag
        }
        FreeTree(T);
        scanf("%d",&N);
    }
    return 0;
}

```


### 代码感悟
判断是不是同一棵BST树主要有三种方法（本题采用第三种方法）：
一是建立两棵树，递归判断每一个节点是否相等即可；  
二是不需建立树，找到根节点后，将比根节点小的数放在左边，大的数放在右边，例如3 1 2 4和3 4 1 2，比较后3 1 4 2变为{1 2} 3 {4}（注意顺序不要改变），3 4 1 2变为{1 2} 3 {4},两者是一致的，所以BST树一致；   
三是建立一棵树，但是树的数据结构中要加入访问标记flag，关键函数是check函数，judge函数输入的时候不论是不是同一棵BST树，都要把数据输完才能进行下一组数据的输入。

